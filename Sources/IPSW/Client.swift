//
// Client.swift
// Copyright (c) 2023 BrightDigit.
//

// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
  @preconcurrency import struct Foundation.Data
  @preconcurrency import struct Foundation.Date
  @preconcurrency import struct Foundation.URL
#else
  import struct Foundation.Data
  import struct Foundation.Date
  import struct Foundation.URL
#endif
import HTTPTypes
/// Download current and previous versions of Apple's iOS Firmware, iTunes and OTA updates.
public struct Client: APIProtocol {
  /// The underlying HTTP client.
  private let client: UniversalClient
  /// Creates a new client.
  /// - Parameters:
  ///   - serverURL: The server URL that the client connects to. Any server
  ///   URLs defined in the OpenAPI document are available as static methods
  ///   on the ``Servers`` type.
  ///   - configuration: A set of configuration values for the client.
  ///   - transport: A transport that performs HTTP operations.
  ///   - middlewares: A list of middlewares to call before the transport.
  public init(
    serverURL: Foundation.URL,
    configuration: Configuration = .init(),
    transport: any ClientTransport,
    middlewares: [any ClientMiddleware] = []
  ) {
    self.client = .init(
      serverURL: serverURL,
      configuration: configuration,
      transport: transport,
      middlewares: middlewares
    )
  }

  private var converter: Converter {
    client.converter
  }

  /// Get Firmwares For Device
  ///
  /// GetFirmwaresForDevice returns Firmwares for a given Device. An optional "type" get parameter may be
  /// specified to retrieve OTA Firmwares instead of normal IPSW files.
  /// As of 2021-03-04, it is recommended that you use the "boards" property of the device, as devices can have multiple boards.
  ///
  /// - Remark: HTTP `GET /device/{identifier}`.
  /// - Remark: Generated from `#/paths//device/{identifier}/get(firmwaresForDevice)`.
  public func firmwaresForDevice(_ input: Operations.firmwaresForDevice.Input) async throws -> Operations.firmwaresForDevice.Output {
    try await client.send(
      input: input,
      forOperation: Operations.firmwaresForDevice.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/device/{}",
          parameters: [
            input.path.identifier
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .get
        )
        suppressMutabilityWarning(&request)
        try converter.setQueryItemAsURI(
          in: &request,
          style: .form,
          explode: true,
          name: "type",
          value: input.query._type
        )
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        return (request, nil)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let headers: Operations.firmwaresForDevice.Output.Ok.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            Cache_hyphen_Control: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Cache-Control",
              as: Swift.String.self
            ),
            Expires: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Expires",
              as: Swift.String.self
            ),
            X_hyphen_Data_hyphen_Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Data-Location",
              as: Swift.String.self
            )
          )
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.firmwaresForDevice.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json",
              "application/x-plist",
              "application/xml"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.Device.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          case "application/x-plist":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .application_x_hyphen_plist(value)
              }
            )
          case "application/xml":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .xml(value)
              }
            )

          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(
            headers: headers,
            body: body
          ))

        case 404:
          let headers: Operations.firmwaresForDevice.Output.NotFound.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            X_hyphen_Data_hyphen_Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Data-Location",
              as: Swift.String.self
            )
          )
          return .notFound(.init(headers: headers))

        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }

  /// Get Devices
  ///
  /// GetDevices returns a list of all devices known to IPSW Downloads
  /// If you wish to only get devices which have Firmware Keys, add the ?keysOnly=true parameter.
  /// As of 2021-03-04, it is recommended that you use the "boards" property of each device, as devices can have multiple boards.
  ///
  /// - Remark: HTTP `GET /devices`.
  /// - Remark: Generated from `#/paths//devices/get(devices)`.
  public func devices(_ input: Operations.devices.Input) async throws -> Operations.devices.Output {
    try await client.send(
      input: input,
      forOperation: Operations.devices.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/devices",
          parameters: []
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .get
        )
        suppressMutabilityWarning(&request)
        try converter.setQueryItemAsURI(
          in: &request,
          style: .form,
          explode: true,
          name: "keysOnly",
          value: input.query.keysOnly
        )
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        return (request, nil)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let headers: Operations.devices.Output.Ok.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            Cache_hyphen_Control: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Cache-Control",
              as: Swift.String.self
            ),
            Expires: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Expires",
              as: Swift.String.self
            ),
            X_hyphen_Data_hyphen_Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Data-Location",
              as: Swift.String.self
            )
          )
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.devices.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json",
              "application/x-plist",
              "application/xml"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Operations.devices.Output.Ok.Body.jsonPayload.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          case "application/x-plist":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .application_x_hyphen_plist(value)
              }
            )
          case "application/xml":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .xml(value)
              }
            )

          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(
            headers: headers,
            body: body
          ))

        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }

  /// Download IPSW
  ///
  /// DownloadIPSW redirects to download an IPSW as specified by its identifier and buildid
  ///
  /// - Remark: HTTP `GET /ipsw/download/{identifier}/{buildid}`.
  /// - Remark: Generated from `#/paths//ipsw/download/{identifier}/{buildid}/get(ipswDownload)`.
  public func ipswDownload(_ input: Operations.ipswDownload.Input) async throws -> Operations.ipswDownload.Output {
    try await client.send(
      input: input,
      forOperation: Operations.ipswDownload.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/ipsw/download/{}/{}",
          parameters: [
            input.path.identifier,
            input.path.buildid
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .get
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        return (request, nil)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 302:
          let headers: Operations.ipswDownload.Output.Found.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Location",
              as: Swift.String.self
            )
          )
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.ipswDownload.Output.Found.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "text/html"
            ]
          )
          switch chosenContentType {
          case "text/html":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .text_html_charset_utf_hyphen_8(value)
              }
            )

          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .found(.init(
            headers: headers,
            body: body
          ))

        case 404:
          let headers: Operations.ipswDownload.Output.NotFound.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            X_hyphen_Data_hyphen_Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Data-Location",
              as: Swift.String.self
            )
          )
          return .notFound(.init(headers: headers))

        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }

  /// Get IPSW Information
  ///
  /// GetIPSWInformation returns all known information for an IPSW as specified by identifier and buildid
  ///
  /// - Remark: HTTP `GET /ipsw/{identifier}/{buildid}`.
  /// - Remark: Generated from `#/paths//ipsw/{identifier}/{buildid}/get(ipswByIdentifierAndBuild)`.
  public func ipswByIdentifierAndBuild(_ input: Operations.ipswByIdentifierAndBuild.Input) async throws -> Operations.ipswByIdentifierAndBuild.Output {
    try await client.send(
      input: input,
      forOperation: Operations.ipswByIdentifierAndBuild.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/ipsw/{}/{}",
          parameters: [
            input.path.identifier,
            input.path.buildid
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .get
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        return (request, nil)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let headers: Operations.ipswByIdentifierAndBuild.Output.Ok.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            Cache_hyphen_Control: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Cache-Control",
              as: Swift.String.self
            ),
            Expires: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Expires",
              as: Swift.String.self
            ),
            X_hyphen_Data_hyphen_Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Data-Location",
              as: Swift.String.self
            )
          )
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.ipswByIdentifierAndBuild.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json",
              "application/x-plist",
              "application/xml"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.Firmware.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          case "application/x-plist":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .application_x_hyphen_plist(value)
              }
            )
          case "application/xml":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .xml(value)
              }
            )

          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(
            headers: headers,
            body: body
          ))

        case 404:
          let headers: Operations.ipswByIdentifierAndBuild.Output.NotFound.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            X_hyphen_Data_hyphen_Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Data-Location",
              as: Swift.String.self
            )
          )
          return .notFound(.init(headers: headers))

        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }

  /// Get IPSW List For Version
  ///
  /// GetIPSWListForVersion finds all IPSW files for a given iOS version
  ///
  /// - Remark: HTTP `GET /ipsw/{version}`.
  /// - Remark: Generated from `#/paths//ipsw/{version}/get(ipswListForVersion)`.
  public func ipswListForVersion(_ input: Operations.ipswListForVersion.Input) async throws -> Operations.ipswListForVersion.Output {
    try await client.send(
      input: input,
      forOperation: Operations.ipswListForVersion.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/ipsw/{}",
          parameters: [
            input.path.version
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .get
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        return (request, nil)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let headers: Operations.ipswListForVersion.Output.Ok.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            Cache_hyphen_Control: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Cache-Control",
              as: Swift.String.self
            ),
            Expires: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Expires",
              as: Swift.String.self
            ),
            X_hyphen_Data_hyphen_Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Data-Location",
              as: Swift.String.self
            )
          )
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.ipswListForVersion.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json",
              "application/x-plist",
              "application/xml"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Operations.ipswListForVersion.Output.Ok.Body.jsonPayload.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          case "application/x-plist":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .application_x_hyphen_plist(value)
              }
            )
          case "application/xml":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .xml(value)
              }
            )

          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(
            headers: headers,
            body: body
          ))

        case 404:
          let headers: Operations.ipswListForVersion.Output.NotFound.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            X_hyphen_Data_hyphen_Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Data-Location",
              as: Swift.String.self
            )
          )
          return .notFound(.init(headers: headers))

        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }

  /// Download Itunes
  ///
  /// DownloadItunes redirects to download an iTunes installer as specified by its platform and version, and architecture for windows
  ///
  /// - Remark: HTTP `GET /itunes/download/{platform}/{version}`.
  /// - Remark: Generated from `#/paths//itunes/download/{platform}/{version}/get(itunesDownloadForPlatformAndVersion)`.
  public func itunesDownloadForPlatformAndVersion(_ input: Operations.itunesDownloadForPlatformAndVersion.Input) async throws -> Operations.itunesDownloadForPlatformAndVersion.Output {
    try await client.send(
      input: input,
      forOperation: Operations.itunesDownloadForPlatformAndVersion.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/itunes/download/{}/{}",
          parameters: [
            input.path.platform,
            input.path.version
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .get
        )
        suppressMutabilityWarning(&request)
        try converter.setQueryItemAsURI(
          in: &request,
          style: .form,
          explode: true,
          name: "arch",
          value: input.query.arch
        )
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        return (request, nil)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 302:
          let headers: Operations.itunesDownloadForPlatformAndVersion.Output.Found.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Location",
              as: Swift.String.self
            )
          )
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.itunesDownloadForPlatformAndVersion.Output.Found.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "text/html"
            ]
          )
          switch chosenContentType {
          case "text/html":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .text_html_charset_utf_hyphen_8(value)
              }
            )

          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .found(.init(
            headers: headers,
            body: body
          ))

        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }

  /// Find Itunes
  ///
  /// FindItunes finds FindItunes versions for a given platform. specify either "windows" or "macOS"
  ///
  /// - Remark: HTTP `GET /itunes/{platform}`.
  /// - Remark: Generated from `#/paths//itunes/{platform}/get(itunesForPlatform)`.
  public func itunesForPlatform(_ input: Operations.itunesForPlatform.Input) async throws -> Operations.itunesForPlatform.Output {
    try await client.send(
      input: input,
      forOperation: Operations.itunesForPlatform.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/itunes/{}",
          parameters: [
            input.path.platform
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .get
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        return (request, nil)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let headers: Operations.itunesForPlatform.Output.Ok.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            Cache_hyphen_Control: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Cache-Control",
              as: Swift.String.self
            ),
            Expires: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Expires",
              as: Swift.String.self
            ),
            X_hyphen_Data_hyphen_Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Data-Location",
              as: Swift.String.self
            )
          )
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.itunesForPlatform.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json",
              "application/x-plist",
              "application/xml"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Operations.itunesForPlatform.Output.Ok.Body.jsonPayload.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          case "application/x-plist":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .application_x_hyphen_plist(value)
              }
            )
          case "application/xml":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .xml(value)
              }
            )

          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(
            headers: headers,
            body: body
          ))

        case 404:
          let headers: Operations.itunesForPlatform.Output.NotFound.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            X_hyphen_Data_hyphen_Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Data-Location",
              as: Swift.String.self
            )
          )
          return .notFound(.init(headers: headers))

        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }

  /// Keys Device List
  ///
  /// KeysDeviceList returns the firmwares which have keys for a given device
  ///
  /// - Remark: HTTP `GET /keys/device/{identifier}`.
  /// - Remark: Generated from `#/paths//keys/device/{identifier}/get(firmwareKeysForIdentifier)`.
  public func firmwareKeysForIdentifier(_ input: Operations.firmwareKeysForIdentifier.Input) async throws -> Operations.firmwareKeysForIdentifier.Output {
    try await client.send(
      input: input,
      forOperation: Operations.firmwareKeysForIdentifier.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/keys/device/{}",
          parameters: [
            input.path.identifier
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .get
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        return (request, nil)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let headers: Operations.firmwareKeysForIdentifier.Output.Ok.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            Cache_hyphen_Control: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Cache-Control",
              as: Swift.String.self
            ),
            Expires: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Expires",
              as: Swift.String.self
            ),
            X_hyphen_Data_hyphen_Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Data-Location",
              as: Swift.String.self
            )
          )
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.firmwareKeysForIdentifier.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json",
              "application/x-plist",
              "application/xml"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Operations.firmwareKeysForIdentifier.Output.Ok.Body.jsonPayload.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          case "application/x-plist":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .application_x_hyphen_plist(value)
              }
            )
          case "application/xml":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .xml(value)
              }
            )

          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(
            headers: headers,
            body: body
          ))

        case 404:
          let headers: Operations.firmwareKeysForIdentifier.Output.NotFound.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            X_hyphen_Data_hyphen_Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Data-Location",
              as: Swift.String.self
            )
          )
          return .notFound(.init(headers: headers))

        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }

  /// Keys For IPSW
  ///
  /// KeysForIPSW returns FirmwareKeys for a given IPSW
  ///
  /// - Remark: HTTP `GET /keys/ipsw/{identifier}/{buildid}`.
  /// - Remark: Generated from `#/paths//keys/ipsw/{identifier}/{buildid}/get(firmwareKeysForIdentifierAndBuild)`.
  public func firmwareKeysForIdentifierAndBuild(_ input: Operations.firmwareKeysForIdentifierAndBuild.Input) async throws -> Operations.firmwareKeysForIdentifierAndBuild.Output {
    try await client.send(
      input: input,
      forOperation: Operations.firmwareKeysForIdentifierAndBuild.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/keys/ipsw/{}/{}",
          parameters: [
            input.path.identifier,
            input.path.buildid
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .get
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        return (request, nil)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let headers: Operations.firmwareKeysForIdentifierAndBuild.Output.Ok.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            Cache_hyphen_Control: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Cache-Control",
              as: Swift.String.self
            ),
            Expires: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Expires",
              as: Swift.String.self
            ),
            X_hyphen_Data_hyphen_Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Data-Location",
              as: Swift.String.self
            )
          )
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.firmwareKeysForIdentifierAndBuild.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json",
              "application/x-plist",
              "application/xml"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Operations.firmwareKeysForIdentifierAndBuild.Output.Ok.Body.jsonPayload.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          case "application/x-plist":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .application_x_hyphen_plist(value)
              }
            )
          case "application/xml":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .xml(value)
              }
            )

          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(
            headers: headers,
            body: body
          ))

        case 404:
          let headers: Operations.firmwareKeysForIdentifierAndBuild.Output.NotFound.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            X_hyphen_Data_hyphen_Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Data-Location",
              as: Swift.String.self
            )
          )
          return .notFound(.init(headers: headers))

        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }

  /// Identify Model
  ///
  /// IdentifyModel finds the identifier of a given model number
  ///
  /// - Remark: HTTP `GET /model/{model}`.
  /// - Remark: Generated from `#/paths//model/{model}/get(identifierForModel)`.
  public func identifierForModel(_ input: Operations.identifierForModel.Input) async throws -> Operations.identifierForModel.Output {
    try await client.send(
      input: input,
      forOperation: Operations.identifierForModel.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/model/{}",
          parameters: [
            input.path.model
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .get
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        return (request, nil)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let headers: Operations.identifierForModel.Output.Ok.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            Cache_hyphen_Control: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Cache-Control",
              as: Swift.String.self
            ),
            Expires: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Expires",
              as: Swift.String.self
            ),
            X_hyphen_Data_hyphen_Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Data-Location",
              as: Swift.String.self
            )
          )
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.identifierForModel.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json",
              "application/x-plist",
              "application/xml"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Operations.identifierForModel.Output.Ok.Body.jsonPayload.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          case "application/x-plist":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .application_x_hyphen_plist(value)
              }
            )
          case "application/xml":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .xml(value)
              }
            )

          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(
            headers: headers,
            body: body
          ))

        case 404:
          let headers: Operations.identifierForModel.Output.NotFound.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            X_hyphen_Data_hyphen_Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Data-Location",
              as: Swift.String.self
            )
          )
          return .notFound(.init(headers: headers))

        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }

  /// OTA Documentation
  ///
  /// OTADocumentation returns the documentation for a given device type and version
  ///
  /// - Remark: HTTP `GET /ota/documentation/{device}/{version}`.
  /// - Remark: Generated from `#/paths//ota/documentation/{device}/{version}/get(otaDocumentationForDeviceAndVersion)`.
  public func otaDocumentationForDeviceAndVersion(_ input: Operations.otaDocumentationForDeviceAndVersion.Input) async throws -> Operations.otaDocumentationForDeviceAndVersion.Output {
    try await client.send(
      input: input,
      forOperation: Operations.otaDocumentationForDeviceAndVersion.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/ota/documentation/{}/{}",
          parameters: [
            input.path.device,
            input.path.version
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .get
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        return (request, nil)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let headers: Operations.otaDocumentationForDeviceAndVersion.Output.Ok.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            Cache_hyphen_Control: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Cache-Control",
              as: Swift.String.self
            ),
            Expires: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Expires",
              as: Swift.String.self
            ),
            X_hyphen_Data_hyphen_Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Data-Location",
              as: Swift.String.self
            ),
            X_hyphen_Frame_hyphen_Options: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Frame-Options",
              as: Swift.String.self
            )
          )
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.otaDocumentationForDeviceAndVersion.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "text/html"
            ]
          )
          switch chosenContentType {
          case "text/html":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .html(value)
              }
            )

          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(
            headers: headers,
            body: body
          ))

        case 404:
          let headers: Operations.otaDocumentationForDeviceAndVersion.Output.NotFound.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            Cache_hyphen_Control: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Cache-Control",
              as: Swift.String.self
            ),
            Expires: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Expires",
              as: Swift.String.self
            ),
            X_hyphen_Data_hyphen_Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Data-Location",
              as: Swift.String.self
            )
          )
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.otaDocumentationForDeviceAndVersion.Output.NotFound.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Operations.otaDocumentationForDeviceAndVersion.Output.NotFound.Body.jsonPayload.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )

          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .notFound(.init(
            headers: headers,
            body: body
          ))

        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }

  /// Download OTA
  ///
  /// DownloadOTA redirects to download an OTA Firmware as specified by its identifier, buildid and optionally prerequisite
  ///
  /// - Remark: HTTP `GET /ota/download/{identifier}/{buildid}`.
  /// - Remark: Generated from `#/paths//ota/download/{identifier}/{buildid}/get(otaDownloadForIdentifierAndBuild)`.
  public func otaDownloadForIdentifierAndBuild(_ input: Operations.otaDownloadForIdentifierAndBuild.Input) async throws -> Operations.otaDownloadForIdentifierAndBuild.Output {
    try await client.send(
      input: input,
      forOperation: Operations.otaDownloadForIdentifierAndBuild.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/ota/download/{}/{}",
          parameters: [
            input.path.identifier,
            input.path.buildid
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .get
        )
        suppressMutabilityWarning(&request)
        try converter.setQueryItemAsURI(
          in: &request,
          style: .form,
          explode: true,
          name: "prerequisite",
          value: input.query.prerequisite
        )
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        return (request, nil)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 302:
          let headers: Operations.otaDownloadForIdentifierAndBuild.Output.Found.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Location",
              as: Swift.String.self
            )
          )
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.otaDownloadForIdentifierAndBuild.Output.Found.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "text/html"
            ]
          )
          switch chosenContentType {
          case "text/html":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .text_html_charset_utf_hyphen_8(value)
              }
            )

          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .found(.init(
            headers: headers,
            body: body
          ))

        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }

  /// Get OTA Information
  ///
  /// GetOTAInformation returns all known information for an OTA specified by its identifier and build (and optionally
  /// prerequisite firmware)
  ///
  /// - Remark: HTTP `GET /ota/{identifier}/{buildid}`.
  /// - Remark: Generated from `#/paths//ota/{identifier}/{buildid}/get(otaInformationForIdentifierAndBuild)`.
  public func otaInformationForIdentifierAndBuild(_ input: Operations.otaInformationForIdentifierAndBuild.Input) async throws -> Operations.otaInformationForIdentifierAndBuild.Output {
    try await client.send(
      input: input,
      forOperation: Operations.otaInformationForIdentifierAndBuild.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/ota/{}/{}",
          parameters: [
            input.path.identifier,
            input.path.buildid
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .get
        )
        suppressMutabilityWarning(&request)
        try converter.setQueryItemAsURI(
          in: &request,
          style: .form,
          explode: true,
          name: "prerequisite",
          value: input.query.prerequisite
        )
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        return (request, nil)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let headers: Operations.otaInformationForIdentifierAndBuild.Output.Ok.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            Cache_hyphen_Control: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Cache-Control",
              as: Swift.String.self
            ),
            Expires: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Expires",
              as: Swift.String.self
            ),
            X_hyphen_Data_hyphen_Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Data-Location",
              as: Swift.String.self
            )
          )
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.otaInformationForIdentifierAndBuild.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json",
              "application/x-plist",
              "application/xml"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Operations.otaInformationForIdentifierAndBuild.Output.Ok.Body.jsonPayload.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          case "application/x-plist":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .application_x_hyphen_plist(value)
              }
            )
          case "application/xml":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .xml(value)
              }
            )

          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(
            headers: headers,
            body: body
          ))

        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }

  /// Get OTA List For Version
  ///
  /// GetOTAListForVersion finds all OTA files for a given iOS version
  ///
  /// - Remark: HTTP `GET /ota/{version}`.
  /// - Remark: Generated from `#/paths//ota/{version}/get(otasForVersion)`.
  public func otasForVersion(_ input: Operations.otasForVersion.Input) async throws -> Operations.otasForVersion.Output {
    try await client.send(
      input: input,
      forOperation: Operations.otasForVersion.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/ota/{}",
          parameters: [
            input.path.version
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .get
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        return (request, nil)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let headers: Operations.otasForVersion.Output.Ok.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            Cache_hyphen_Control: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Cache-Control",
              as: Swift.String.self
            ),
            Expires: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Expires",
              as: Swift.String.self
            ),
            X_hyphen_Data_hyphen_Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Data-Location",
              as: Swift.String.self
            )
          )
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.otasForVersion.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json",
              "application/x-plist",
              "application/xml"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Operations.otasForVersion.Output.Ok.Body.jsonPayload.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          case "application/x-plist":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .application_x_hyphen_plist(value)
              }
            )
          case "application/xml":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .xml(value)
              }
            )

          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(
            headers: headers,
            body: body
          ))

        case 404:
          let headers: Operations.otasForVersion.Output.NotFound.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            X_hyphen_Data_hyphen_Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Data-Location",
              as: Swift.String.self
            )
          )
          return .notFound(.init(headers: headers))

        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }

  /// Releases
  ///
  /// Releases returns the release timeline of all entities in the IPSW Downloads database
  ///
  /// - Remark: HTTP `GET /releases`.
  /// - Remark: Generated from `#/paths//releases/get(releases)`.
  public func releases(_ input: Operations.releases.Input) async throws -> Operations.releases.Output {
    try await client.send(
      input: input,
      forOperation: Operations.releases.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/releases",
          parameters: []
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .get
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        return (request, nil)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let headers: Operations.releases.Output.Ok.Headers = try .init(
            Access_hyphen_Control_hyphen_Allow_hyphen_Methods: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Methods",
              as: Swift.String.self
            ),
            Access_hyphen_Control_hyphen_Allow_hyphen_Origin: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Access-Control-Allow-Origin",
              as: Swift.String.self
            ),
            Cache_hyphen_Control: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Cache-Control",
              as: Swift.String.self
            ),
            Expires: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "Expires",
              as: Swift.String.self
            ),
            X_hyphen_Data_hyphen_Location: converter.getOptionalHeaderFieldAsURI(
              in: response.headerFields,
              name: "X-Data-Location",
              as: Swift.String.self
            )
          )
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.releases.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json",
              "application/x-plist",
              "application/xml"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Operations.releases.Output.Ok.Body.jsonPayload.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          case "application/x-plist":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .application_x_hyphen_plist(value)
              }
            )
          case "application/xml":
            body = try converter.getResponseBodyAsBinary(
              OpenAPIRuntime.HTTPBody.self,
              from: responseBody,
              transforming: { value in
                .xml(value)
              }
            )

          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(
            headers: headers,
            body: body
          ))

        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }
}
